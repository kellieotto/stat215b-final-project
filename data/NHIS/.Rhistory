}
@
Define the permutation test. Note that permutation treatment and control group sizes will vary depending on how many participants registered for two draws win two prizes.
<<>>=
Permutation.Test<-function(box,outcome,y,prizes,L=1000,two.sided=TRUE){
#specify outcome
outcome$y <- y
#create vector to store permutation t-stats
new.t.stats<-rep(0,L)
#iterate permutation test L times
for(i in 1:L){
#create permutation assignment vector
Z <-sample(c(rep(1,prizes), rep(0,length(box) - prizes)), replace=FALSE)
#permutation assignment IDs (remove second entry)
new.t <- sort(unique(box[Z==1]))
new.c <- sort(unique(box [! box %in% new.t]))
perm.treat <- rbind(cbind(new.t,1),cbind(new.c,0))
colnames(perm.treat) <- c("row.no","perm.treat")
#link to observed outcomes
perm.outcome <- merge(outcome,perm.treat,by= "row.no")
#calculate permutation test statistic
new.t.stats[i]<-est.ate(perm.outcome$y,perm.outcome$perm.treat,perm.outcome$draw,box,prizes)
}
#calculate p value
if (two.sided){
pvalue<-sum(abs(new.t.stats) >= abs(est.ate(outcome$y,outcome$treat,outcome$draw,box,prizes)))/L
}
else {
pvalue<-sum(new.t.stats >= est.ate(outcome$y,outcome$treat,outcome$draw,box,prizes))/L
}
#return p-value and permutation vectors
return(list("p" = pvalue, "perm.t.stats" = new.t.stats))
}
@
Call \texttt{Permutation.Test}. Report observed t--stat.
<<>>=
#call function
patient <- FALSE
if(patient){
results <- Permutation.Test(box,outcome05,y=outcome05$oh,prizes)
#what is observed t-stat?
observed.t.stat <- est.ate(outcome05$oh,outcome05$treat,outcome05$draw,box,prizes)
#create histogram of permutation distribution
hist.plot <- qplot(results$perm.t.stats, geom="histogram",xlab=expression(delta), ylab="Count",binwidth=0.0001) + labs(title="Treatment effect on officeholding") + geom_vline(aes(xintercept=round(observed.t.stat,3)), colour="red", linetype = "longdash") + scale_x_continuous(breaks=c(-0.01,0,round(observed.t.stat,3)),labels=c("-0.01","0",round(observed.t.stat,3)))
}
#report p-value and t-stat
results$p
observed.t.stat
@
Estimate randomization confidence intervals. Assume a constant treatment effect.
<<>>=
#define function
perm.CI <- function(alpha=0.05,box,outcome,y,prizes,l=1000,L=10) {
#define treatment and control
treat <- outcome$treat
#create vector to store CIs
CI<-rep(0,l)
for(i in 1:l){
#choose constant treatment effect
delta.c <- sample(seq(-1,1,by=0.00001),1,replace=FALSE)
#subtract from all of treated outcomes
y.delta<- ifelse(treat==1,y-abs(delta.c),y)
#run permuation test
results <- Permutation.Test(box,outcome,y=y.delta,prizes,L)
#if result not significant, delta.c is in confidence interval
CI[i] <- ifelse(results$p>alpha,delta.c,NA)
}
return(range(CI,na.rm=TRUE))
}
#report(100-alpha)% CI
if(patient){
results.CI <- perm.CI(alpha=0.05,box,outcome05,y=outcome05$oh,prizes)
}
results.CI
@
\subsection{Sensitivity analysis: 1807 sample included}
<<>>=
# Subset 1807 data
fdg07$treat <- 1 # add treatment indicator
outcome07 <- subset(fdg07,fdg07$orphan!=1 & fdg07$widow!=1 & fdg07$prior.office!=1 & fdg07$female!=1, select=c("id","oh","grant.book","treat"))
colnames(outcome07) <- c("row.no","oh","grant.book","treat")
# Add 1807 winners to 1805 data
lotteries <- rbind(outcome05[c("row.no","oh","treat")],outcome07[c("row.no","oh","treat")])
@
Create contingency tables showing officeholder totals by treatment group.
<<>>=
# 1805 sample
tableNominal(vars = outcome05[c("oh")], group = outcome05$treat, prec = 3,cumsum=FALSE,lab = "outcomes05")
#1805 + 1807 sample
tableNominal(vars = lotteries[c("oh")], group = lotteries$treat, prec = 3,cumsum=FALSE,main="1805 and 1807 lottery participants", lab = "lotteries")
# Power for 1805
power.05 <- power2x2(p0=mean(outcome05$oh[outcome05$treat==0]),p1=mean(outcome05$oh[outcome05$treat==1]),n0=sum(outcome05$treat==0),n1=sum(outcome05$treat==1),sig.level=0.05,
alternative=c("two.sided"))
power.05
# Power for combined sample
power.combined <- power2x2(p0=mean(lotteries$oh[lotteries$treat==0]),p1=mean(lotteries$oh[lotteries$treat==1]),n0=sum(lotteries$treat==0),n1=sum(lotteries$treat==1),sig.level=0.05,
alternative=c("two.sided"))
power.combined
@
\section{Sensitivity analysis: treatment--on--the--treated (TOT)}
<<>>=
## For the 1805 sample
# Create dummy for never-treat
outcome05$rgb <- 0
outcome05$rgb[c(grep("RGB",outcome05$grant.book.x),grep("RGB",outcome05$grant.book.y))] <- 1
#create dummy for treatment received
outcome05$tot <- outcome05$treat
outcome05$tot[outcome05$rgb==1] <- 0
## For the combined sample
# Create dummy for never-treat
outcome07$rgb <- 0
outcome07$rgb[c(grep("Rev",outcome07$grant.book))] <- 1
#create dummy for treatment received
outcome07$tot <- outcome07$treat
outcome07$tot[outcome07$rgb==1] <- 0
@
Create table showing officeholder totals by treatment group and compliance status.
<<>>=
#partition groups for table (0 = control; 1 = complier; 2= never-treat)
outcome05$partition <- outcome05$treat  # 1805
outcome05$partition[outcome05$rgb==1] <- 2
outcome07$partition <- outcome07$treat # 1807
outcome07$partition[outcome07$rgb==1] <- 2
# Combine data
lotteries.tot <- rbind(outcome05[c("row.no","oh","treat","rgb","tot","partition")],outcome07[c("row.no","oh","treat","rgb","tot","partition")])
#create tables
tableNominal(vars = outcome05[c("oh")], group = c(outcome05$partition), prec = 3,cumsum=FALSE,lab = "outcome05-compliance") #1805
tableNominal(vars = lotteries.tot[c("oh")], group = c(lotteries.tot$partition), prec = 3,cumsum=FALSE, lab = "lotteries-compliance-combined") # combined
@
IV analysis.
<<>>=
results3 <- ivreg(oh ~ tot | treat, data=outcome05)
results3.3 <- ivreg(oh ~ tot | treat, data=lotteries.tot) # combined
#produce table of results
toLatex(mtable(results3,results3.3))
# get confidence interval for combined model
confint(results3.3, level =0.95)
@
\section{Balance}
Make QQ plots for continuous name variables.
<<>>=
# Make df for plots
continuous.balance <- subset(lot05,lot05$orphan!=1 & lot05$widow!=1 & lot05$prior.office!=1, select=c("row.no","treat","draw","surname.freq","surname.length"))
#QQ plot for surname frequency
qqplot(continuous.balance$surname.freq[continuous.balance$treat==1],continuous.balance$surname.freq[continuous.balance$treat==0],xlim=c(50,350),ylim=c(50,350),ylab="Control",xlab="Treated",main="Surname frequency")
abline(0,1,col="red")
abline(v=0)
abline(h=0)
#QQ plot for surname length
qq.length <- qqplot(continuous.balance$surname.length[continuous.balance$treat==1],continuous.balance$surname.length[continuous.balance$treat==0],xlim=c(1,15),ylim=c(1,15),ylab="Control",xlab="Treated",main="Surname length")
abline(0,1,col="red")
abline(v=0)
abline(h=0)
@
\section{Treatment effect on support for slavery}
Calculate observed test statistic, randomization $p$ value, and confidence interval for 1805 legislator-participants.
<<>>=
outcome.assembly <- subset(lot05,oh==1 & !is.na(vote.index), select=c("row.no","draw","treat","vote.index"))
#what is observed t-stat?
observed.t.assembly <- est.ate(outcome.assembly$vote.index,outcome.assembly$treat,outcome.assembly$draw,box,prizes)
observed.t.assembly
if(patient) {
#call perm test
results.assembly <- Permutation.Test(box,outcome.assembly,y=outcome.assembly$vote.index,prizes)
#create histogram of permutation distribution
hist.plot4 <- qplot(results.assembly $perm.t.stats, geom="histogram",xlab=expression(delta), ylab="Count",binwidth=0.001) + labs(title="Treatment effect on demand for slavery") + geom_vline(aes(xintercept=round(observed.t.assembly,3)), colour="red", linetype = "longdash") + scale_x_continuous(breaks=c(-0.2,0,0.2,round(observed.t.assembly,3)),labels=c("-0.2","0","0.2",round(observed.t.assembly,3)))
#report(100-alpha)% CI
assembly.CI <- perm.CI(alpha=0.05,box,outcome.assembly,y=outcome.assembly$vote.index,prizes)
}
# Retreive p and CI
results.assembly$p
assembly.CI
# Combine randomization plots
vplayout <- function(x, y) viewport(layout.pos.row = x, layout.pos.col = y)
grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 2)))
print(hist.plot, vp = vplayout(1, 1))
print(hist.plot4, vp=vplayout(1,2))
@
<<>>=
## 1805 officeholders
officeholders05 <- subset(lot05,oh==1, select=c("row.no","sound.first","name","surname","first.name","grant.book.x","grant.book.y","name.1","office.1","const.1","name.2","office.2","const.2","name.3","office.3","const.3","name.4","office.4","const.4","prior.office","treat","vote.index"))
# Create dummy for never-treat
officeholders05$rgb <- 0
officeholders05$rgb[c(grep("RGB",officeholders05$grant.book.x),grep("RGB",officeholders05$grant.book.y))] <- 1
#create dummy for treatment received
officeholders05$tot <- officeholders05$treat
officeholders05$tot[officeholders05$rgb==1] <- 0
# Create lottery indicator
officeholders05$lottery <- "1805"
## 1807 officeholders
officeholders07 <- subset(fdg07,oh==1, select=c("id","sound.first","fortunate.drawer","surname","first.name","grant.book","name","office","const","name.2","office.2","const.2","name.3","office.3","const.3","name.4","office.4","const.4","prior.office","treat","vote.index"))
# Create dummy for never-treat
officeholders07$rgb <- 0
officeholders07$rgb[c(grep("Rev",officeholders07$grant.book))] <- 1
#create dummy for treatment received
officeholders07$tot <- officeholders07$treat
officeholders07$tot[officeholders07$rgb==1] <- 0
# Create lottery indicator
officeholders07$lottery <- "1807"
colnames(officeholders07) <- c("row.no","sound.first","name","surname","first.name","grant.book","name.1","office.1","const.1","name.2","office.2","const.2","name.3","office.3","const.3","name.4","office.4","const.4","prior.office","treat","vote.index","rgb","tot","lottery") # rename to combine
# combine 1805 and 1807
officeholders.lot <- rbind(officeholders05[c("row.no","sound.first","name","surname","first.name","name.1","office.1","const.1","name.2","office.2","const.2","name.3","office.3","const.3","name.4","office.4","const.4","prior.office","treat","vote.index","rgb","tot","lottery")],officeholders07[c("row.no","sound.first","name","surname","first.name","name.1","office.1","const.1","name.2","office.2","const.2","name.3","office.3","const.3","name.4","office.4","const.4","prior.office","treat","vote.index","rgb","tot","lottery")])
# export to csv for linking tax records
if(patient){
write.csv(arrange(officeholders.lot[!is.na(officeholders.lot$vote.index) & is.na(officeholders.lot$ptax.pre) & is.na(officeholders.lot$ptax.post),][c("row.no","surname","first.name","const.1")],surname,first.name), "officeholders.lot.csv", row.names=FALSE, col.names=FALSE)
}
# Import and merge tax records
source("tax-digests-oh.R")
officeholders.lot <- merge(officeholders.lot,oh.taxes.pre,by="row.no",all.x=TRUE)
officeholders.lot <- merge(officeholders.lot,oh.taxes.post,by="row.no",all.x=TRUE)
@
Create table showing outcomes by treatment group.
<<>>=
my.stats <- list("n", "min", "mean", "max", "s","na")
# 1805
tableContinuous(vars = officeholders.lot[officeholders.lot$lottery=="1805",][("vote.index")], group = officeholders.lot$treat, prec = 3,cumsum=FALSE,stats=my.stats)
#combined
tableContinuous(vars = officeholders.lot[("vote.index")], group = officeholders.lot$treat, prec = 3,cumsum=FALSE,stats=my.stats,cap = "Distribution of the outcome variable, by treatment assignment, for lottery participants who held the office in the Georgia General Assembly. `Support for slavery' is the mean of votes in favor of slavery for roll calls in which the member is present.", lab = "outcomes-assembly")
@
Estimate average treatment effect on compliers.
<<>>=
#call IV
results.assembly <- ivreg(vote.index ~ tot | treat, data=officeholders.lot) # Combined
results.assembly05 <- ivreg(vote.index ~ tot | treat, data=officeholders.lot[officeholders.lot$lottery=="1805",]) # 1805
toLatex(mtable(results.assembly05,results.assembly))
@
\section{Summary of average treatment effects}
<<>>=
# Forest plot
ForestPlot <- function(d, xlab, ylab){
p <- ggplot(d, aes(x=x, y=y, ymin=y.lo, ymax=y.hi,colour=Outcome)) +
geom_pointrange(size=1, alpha=0.8) +
coord_flip() +
geom_hline(aes(x=0), lty=2) +
theme(legend.position="none") +
facet_grid(Outcome~.) +
ylab(xlab) +
xlab(ylab) #switch because of the coord_flip() above
return(p)
}
# Create data for plot
plot.data <- data.frame(x = c("ITT [1805]","TOT [1805]", "TOT [Combined]"),
y = c(observed.t.stat,results3$coefficients[2],results3.3$coefficients[2],observed.t.assembly,results.assembly05$coefficients[2],results.assembly$coefficients[2]),
y.lo = c(results.CI[1],confint(results3, level =0.95)[2],confint(results3.3, level =0.95)[2],assembly.CI[1],confint(results.assembly05, level =0.95)[2],confint(results.assembly, level =0.95)[2]),
y.hi = c(results.CI[2],confint(results3, level =0.95)[4],confint(results3.3, level =0.95)[4],assembly.CI[2],confint(results.assembly05, level =0.95)[4],confint(results.assembly, level =0.95)[4]))
plot.data <- transform(plot.data, y.lo = y.lo, y.hi=y.hi)
plot.data$Outcome <- c(rep("Officeholding",3),rep("Slavery",3))
# Plot forest plot
plot.data$x <- factor(plot.data$x, levels=rev(plot.data$x)) # reverse order
ForestPlot(plot.data,xlab="Treatment effect",ylab="Analysis")
@
\section{Heterogenous treatment effects on support for slavery}
Create tables and figures  of pre-- and post--treatment wealth distribution for legislators who voted on roll calls.
<<>>=
# Remove obs without vote index
assembly.het <- officeholders.lot[!is.na(officeholders.lot$vote.index),]
# Specify wealth variables
wealth.vars <- c("slaves.pre","acres.pre","ptax.pre","slaves.post","acres.post","ptax.post")
# Table
tableContinuous(vars = assembly.het[wealth.vars], prec = 3,cumsum=FALSE,stats=list("n", "min", "mean", "max", "s")) # combined
# Make data for histogram
slaves <- melt(data=assembly.het[c("row.no","slaves.pre","slaves.post")], id.vars="row.no")
acres <- melt(data=assembly.het[c("row.no","acres.pre","acres.post")], id.vars="row.no")
ptax <- melt(data=assembly.het[c("row.no","ptax.pre","ptax.post")], id.vars="row.no")
# Plot the overlaid density of pre- and post-treatment wealth for each measure
slaves.hist <- ggplot(slaves, aes(x=value, fill=variable)) + # slaves
geom_density(alpha=.3) +
ylab("Density") +
xlab("Slaves") +
xlim(c(0,30)) +
theme(legend.position="none")
acres.hist <- ggplot(acres, aes(x=value, fill=variable)) + # acres
geom_density(alpha=.3) +
ylab("") +
xlab("Land (acres)") +
xlim(c(0,3000)) +
theme(legend.position="none")
ptax.hist <- ggplot(ptax, aes(x=value, fill=variable)) + # ptax
geom_density(alpha=.3) +
ylab("") +
xlab("Person tax ($)") +
xlim(c(0,30)) +
scale_fill_discrete(name="Measurement",
labels=c("Pretreatment", "Posttreatment")) +
theme(legend.justification = c(1, 1), legend.position = c(1, 1),legend.background = element_rect(colour = "black"))
# Combine plots
grid.newpage()
pushViewport(viewport(layout = grid.layout(1, 3)))
print(slaves.hist, vp = vplayout(1, 1))
print(acres.hist, vp = vplayout(1,2))
print(ptax.hist, vp=vplayout(1,3))
@
Estimate treatment effect heterogeneity in terms of pretreatment wealth county-level slave shares.
<<>>=
# Create dummies for pretreatment vars
Dummies3Cut <- function(x) {
var <- cut(x,
breaks=c(-Inf, summary(x)[[2]], summary(x)[[5]], Inf),
labels=c("low","medium","high"))
return(dummify(var, keep.na=TRUE))
}
slaves.pre <- Dummies3Cut(assembly.het$slaves.pre)
acres.pre <- Dummies3Cut(assembly.het$acres.pre)
ptax.pre <- Dummies3Cut(assembly.het$ptax.pre)
# Create features and outcomes vectors
x07 <- na.omit(data.frame("slaves.pre"=slaves.pre,"acres.pre"=acres.pre,"ptax.pre"=ptax.pre))
y07 <- as.matrix(assembly.het$vote.index[as.numeric(rownames(x07))]) # remove rows with missing predictors
# Run regression model
if (patient){
set.seed(42)
fitSL <- SuperLearner(Y=y07[,1],X=x07,
SL.library=SL.library.reg,
family=gaussian()) # gaussian for continuous resp
}
# Print summary table
print(xtable(data.frame("Algorithm"=fitSL$SL.library$library$predAlgorithm,"Risk"=round(fitSL$cvRisk,3),"Weight"=round(fitSL$coef,3)),lab = "ensemble-tab",caption="Cross--validated risk and weights used for each algorithm in super learner prediction ensemble.",include.rownames = FALSE,booktabs = TRUE,tabular.environment = "longtable"))
# Combine predictions with x and y
het.pred <- cbind(y07,x07,fitSL$SL.predict,assembly.het$treat[as.numeric(rownames(x07))])
colnames(het.pred)[1] <- "vote.index"
colnames(het.pred)[11] <- "vote.index.hat"
colnames(het.pred)[12] <- "treat"
MSPE <- mean((het.pred$vote.index - het.pred$vote.index.hat)^2) # Calculate MSPE
MSPE
## Take differences of response surfaces of the treated
ResponseDiff <- function(x,y.hat=het.pred$vote.index.hat,treat=het.pred$treat) {
return(mean(y.hat[treat==1 & x==1]) - mean(y.hat[treat==1 & x==0]))
}
slaves.pre.low  <- ResponseDiff(x=het.pred$slaves.pre.low)
slaves.pre.medium <- ResponseDiff(x=het.pred$slaves.pre.medium)
slaves.pre.high <- ResponseDiff(x=het.pred$slaves.pre.high)
acres.pre.low  <- ResponseDiff(x=het.pred$acres.pre.low)
acres.pre.medium <- ResponseDiff(x=het.pred$acres.pre.medium)
acres.pre.high <- ResponseDiff(x=het.pred$acres.pre.high)
ptax.pre.low  <- ResponseDiff(x=het.pred$ptax.pre.low)
ptax.pre.medium <- ResponseDiff(x=het.pred$ptax.pre.medium)
ptax.pre.high <- ResponseDiff(x=het.pred$ptax.pre.high)
@
Create dotplot for heterogenous effects by treatment group
<<>>=
# Create data for plot
het.plot <- data.frame(x=rep(c("Low", "Medium", "High"),3), y = c(slaves.pre.low, slaves.pre.medium, slaves.pre.high,acres.pre.low, acres.pre.medium, acres.pre.high, ptax.pre.low, ptax.pre.medium, ptax.pre.high), Measure= c(rep("Slaves",3),rep("Land (acres)",3),rep("Person tax ($)",3)))
# Plot forest plot
het.plot$x <- factor(het.plot$x, levels=rev(het.plot$x)) # reverse order
ggplot(het.plot, aes(x=x, y=y,colour=Measure,group=Measure)) +
geom_point(size=4) +
coord_flip() +
geom_line() +
geom_hline(aes(x=0), lty=2) +
facet_grid(Measure ~.) +
theme(legend.position="none") +
ylab("Treatment effect") +
xlab("") #switch because of the coord_flip() above
@
\section{Heterogenous treatment effects on officeholding}
<<>>=
# Create county dummies
county <- dummify(as.factor(lot05$county))
# Create features and outcomes vectors
x07.2 <- data.frame(county)
y07.2 <- as.matrix(lot05$oh)
# Run regression model
if (patient){
set.seed(42)
fitSL.2 <- SuperLearner(Y=y07.2[,1],X=x07.2,
SL.library=SL.library.class) # switch to classification
}
# Print summary table
print(xtable(data.frame("Algorithm"=fitSL.2$SL.library$library$predAlgorithm,"Risk"=round(fitSL.2$cvRisk,3),"Weight"=round(fitSL.2$coef,3)),include.rownames = FALSE,booktabs = TRUE,tabular.environment = "longtable"))
# Combine predictions with x and y
het.pred2 <- cbind(y07.2,x07.2,fitSL.2$SL.predict,lot05$treat)
colnames(het.pred2)[1] <- "oh"
colnames(het.pred2)[29] <- "oh.hat"
colnames(het.pred2)[30] <- "treat"
MSPE2 <- mean((het.pred2$oh - het.pred2$oh.hat)^2) # Calculate MSPE
MSPE2
# Take differences of response surfaces of the treated
Bryan <- ResponseDiff(x=het.pred2$Bryan,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Bulloch <- ResponseDiff(x=het.pred2$Bulloch,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Burke <- ResponseDiff(x=het.pred2$Burke,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Camden <- ResponseDiff(x=het.pred2$Camden,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Chatham <- ResponseDiff(x=het.pred2$Chatham,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Clarke <- ResponseDiff(x=het.pred2$Clarke,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Columbia <- ResponseDiff(x=het.pred2$Columbia,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Effingham <- ResponseDiff(x=het.pred2$Effingham,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Elbert <- ResponseDiff(x=het.pred2$Elbert,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Franklin <- ResponseDiff(x=het.pred2$Franklin,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Glynn <- ResponseDiff(x=het.pred2$Glynn,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Greene <- ResponseDiff(x=het.pred2$Greene,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Hancock <- ResponseDiff(x=het.pred2$Hancock,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Jackson <- ResponseDiff(x=het.pred2$Jackson,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Jefferson <- ResponseDiff(x=het.pred2$Jefferson,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Liberty <- ResponseDiff(x=het.pred2$Liberty,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Lincoln <- ResponseDiff(x=het.pred2$Lincoln,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Montgomery <- ResponseDiff(x=het.pred2$Montgomery,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Oglethorpe <- ResponseDiff(x=het.pred2$Oglethorpe,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Richmond <- ResponseDiff(x=het.pred2$Richmond,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Screven <- ResponseDiff(x=het.pred2$Screven,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Tattnall <- ResponseDiff(x=het.pred2$Tattnall,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Warren <- ResponseDiff(x=het.pred2$Warren,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Washington <- ResponseDiff(x=het.pred2$Washington,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
Wilkes <- ResponseDiff(x=het.pred2$Wilkes,y.hat=het.pred2$oh.hat,treat=het.pred2$treat)
# Create data for plot
het.plot2 <- data.frame(x=c("Bryan","Bulloch","Burke","Camden","Chatham","Clarke","Columbia","Effingham","Elbert","Franklin","Glynn","Greene","Hancock","Jackson","Jefferson","Liberty","Lincoln","Montgomery","Oglethorpe","Richmond","Screven","Tattnall","Warren","Washington","Wilkes"), y = c(Bryan,Bulloch,Burke,Camden,Chatham,Clarke,Columbia,Effingham,Elbert,Franklin,Glynn,Greene,Hancock,Jackson,Jefferson,Liberty,Lincoln,Montgomery,Oglethorpe,Richmond,Screven,Tattnall,Warren,Washington,Wilkes))
# Merge 1800 county-level slave shares with county
counties.slaves <- subset(counties.00,select=c("name","slave.poppc"))
het.plot2 <- merge(het.plot2,counties.slaves,by.x="x",by.y="name",all.x=TRUE)
# Plot forest plot
het.plot2$x <- factor(het.plot2$x, levels=rev(het.plot2$x)) # reverse order
ggplot(het.plot2, aes(x=x, y=y,colour=slave.poppc)) +
geom_point(size=8, alpha=0.8) +
coord_flip() +
geom_line() +
geom_hline(aes(x=0), lty=2) +
theme(legend.position="top",legend.title=element_blank()) +
ylab("Treatment effect") +
xlab("County of registration") #switch because of the coord_flip() above
@
<<>>=
save.image("analysis.RData")
@
\end{document}
## Estimate conditional expectation of responses in RCT
## Then, use response model to estimate population members' outcomes given their covariates.
## These estimates will be used to estimate the PATT.
# Define directory for analysis
directory <- "~/Dropbox/github/stat215b-final-project/analysis"
# Source scripts
source(file.path(directory,"prepare-analysis.R"))
source(file.path(directory,"SuperLearner.R"))
library(randomForest)
# Create dfs containing common features for RCT and observational study
X.ohie <- na.omit(data.frame(n.hh,  # need to omit rows containing any NA
gender,
age.20to49,
age.50to64,
white,
black,
hisp,
diabetes,
asthma,
bp,
heart,
education,
income))
X.nhis <-   na.omit(data.frame(n.hh.nhis, # need to omit rows containing any NA
gender.nhis,
"age.20to49"=age.20to49.nhis,
"age.50to64"=age.50to64.nhis,
"white"=white.nhis,
"black"=black.nhis,
"hisp"=hisp.nhis,
"diabetes"=diabetes.nhis,
"asthma"=asthma.nhis,
"bp"=bp.nhis,
"heart"=heart.nhis,
education.nhis,
income.nhis))
# Create vectors for treatment and compliance
treatment.ohie <- treatment[as.numeric(rownames(X.ohie))]
insurance.ohie <- insurance[as.numeric(rownames(X.ohie))]
insurance.nhis <- medicaid[as.numeric(rownames(X.nhis))]
# Create dfs for outcomes
Y.ohie <- na.omit(data.frame("any.visit"=any.visit, # need to omit rows containing any NA
"num.visit"=num.visit,
#  "any.hosp"=any.hosp,
#  "num.hosp"=num.hosp,
"any.out"=any.out,
"num.out"=num.out))
Y.nhis <- na.omit(data.frame("any.visit"=nhis.any.visit, # need to omit rows containing any NA
"num.visit"=nhis.num.visit,
#     "any.hosp"=nhis.any.hosp,
"any.out"=nhis.any.out,
"num.out"=nhis.num.out))
# Train compliance model on RCT treated. Use model to predict P(insurance == 1|covariates) on controls.
complier.mod <- suppressWarnings(randomForest(x=X.ohie[treatment.ohie == 1,],
y=insurance.ohie[treatment.ohie==1]))
rct.compliers <- data.frame("treatment"=treatment.ohie,
"insurance"=insurance.ohie,
"C.pscore"=predict(complier.mod, X.ohie),
"C.hat"=ifelse(predict(complier.mod, X.ohie)>=0.5,1,0),
"complier"=0)
rct.compliers$complier[rct.compliers$treatment==1 & rct.compliers$insurance==1] <- 1 # true compliers in the treatment group
rct.compliers$complier[rct.compliers$treatment==0 & rct.compliers$C.hat==1] <- 1 # predicted compliers from the control group
#save(complier.mod, rct.compliers, file = "complier-mod-rf.RData") # save .Rdata
load("complier-mod-rf.RData")
# Predict who is a complier in NRT
nrt.compliers <- data.frame("C.pscore"=predict(complier.mod, X.nhis),
"C.hat"=ifelse(predict(complier.mod, X.nhis)>=0.5,1,0))
# Fit a regression to the compliers in the RCT
y.col <- 1:ncol(Y.ohie) # number of responses
Y.ohie.response <- Y.ohie[which(rct.compliers$complier==1),]
X.ohie.response <- data.frame("treatment"=rct.compliers$treatment[which(rct.compliers$complier==1)],
X.ohie[which(rct.compliers$complier==1),])
response.mod <- lapply(y.col, function(i) randomForest(x=X.ohie.response,
y=Y.ohie.response[,i]))
names(response.mod) <- colnames(Y.ohie.response) # name each element of list
# Use response model to estimate potential outcomes for population "compliers" on medicaid
nrt.tr.counterfactual <- cbind("treatment" = rep(1, length(which(insurance.nhis==1))),
X.nhis[which(insurance.nhis==1),])
nrt.ctrl.counterfactual <- cbind("treatment" = rep(0, length(which(insurance.nhis==1))),
X.nhis[which(insurance.nhis==1),])
Yhat.1 <- lapply(y.col, function (i) predict(response.mod[[i]], nrt.tr.counterfactual))
Yhat.0 <- lapply(y.col, function (i) predict(response.mod[[i]], nrt.ctrl.counterfactual))
# Compute the estimator
term1 <- lapply(y.col, function (i) mean(Yhat.1[[i]]))
term2 <- lapply(y.col, function (i) mean(Yhat.0[[i]]))
tpatt <- lapply(y.col, function (i) term1[[i]] - term2[[i]])
# Compute SATE for comparison
rct.sate <- lapply(y.col, function (i) (mean(Y.ohie[[i]][which(treatment.ohie==1)]) - # Num. is ITT effect
mean(Y.ohie[[i]][which(treatment.ohie==0)]))
/mean(rct.compliers$complier[which(rct.compliers$treatment==1)])) # Denom. is true RCT compliance rate
